{"version":3,"file":"relayer-fee-cache.js","sourceRoot":"","sources":["../../src/fees/relayer-fee-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  CachedTokenFee,\n  Chain,\n  networkForChain,\n} from '@railgun-community/shared-models';\nimport { AddressFilter } from '../filters/address-filter.js';\nimport { RelayerConfig } from '../models/relayer-config.js';\nimport { RelayerDebug } from '../utils/relayer-debug.js';\nimport {\n  nameForRelayer,\n  cachedFeeExpired,\n  DEFAULT_RELAYER_IDENTIFIER,\n  invalidRelayerVersion,\n  cachedFeeUnavailableOrExpired,\n} from '../utils/relayer-util.js';\n\n// {forNetwork: {forToken: {forRelayer: (fee, updatedAt)}}}\ntype RelayerFeeNetworkTokenRelayerCacheMap = {\n  forIdentifier: MapType<CachedTokenFee>;\n};\ntype RelayerFeeNetworkTokenCacheMap = {\n  forRelayer: MapType<RelayerFeeNetworkTokenRelayerCacheMap>;\n};\ntype RelayerFeeNetworkCacheMap = {\n  forToken: MapType<RelayerFeeNetworkTokenCacheMap>;\n};\nexport type RelayerFeeCacheState = {\n  forNetwork: MapType<RelayerFeeNetworkCacheMap>;\n};\n\nexport class RelayerFeeCache {\n  private static cache: RelayerFeeCacheState = { forNetwork: {} };\n\n  static addTokenFees(\n    chain: Chain,\n    railgunAddress: string,\n    feeExpiration: number,\n    tokenFeeMap: MapType<CachedTokenFee>,\n    identifier: Optional<string>,\n    version: string,\n  ) {\n    const network = networkForChain(chain);\n    if (!network) {\n      return;\n    }\n\n    const relayerName = nameForRelayer(railgunAddress, identifier);\n    const networkName = network.name;\n\n    if (invalidRelayerVersion(version)) {\n      RelayerDebug.log(\n        `[Fees] Relayer version ${version} invalid (req ${RelayerConfig.MINIMUM_RELAYER_VERSION}-${RelayerConfig.MAXIMUM_RELAYER_VERSION}): ${relayerName}`,\n      );\n      return;\n    }\n\n    if (cachedFeeExpired(feeExpiration)) {\n      RelayerDebug.log(\n        `[Fees] Fees expired for ${networkName} (${relayerName})`,\n      );\n      return;\n    }\n\n    const tokenAddresses = Object.keys(tokenFeeMap);\n    RelayerDebug.log(\n      `[Fees] Updating fees for ${networkName} (${relayerName}): ${tokenAddresses.length} tokens`,\n    );\n\n    this.cache.forNetwork[networkName] ??= { forToken: {} };\n\n    const tokenAddressesLowercase = tokenAddresses.map(address =>\n      address.toLowerCase(),\n    );\n    tokenAddressesLowercase.forEach(tokenAddress => {\n      this.cache.forNetwork[networkName].forToken[tokenAddress] ??= {\n        forRelayer: {},\n      };\n      this.cache.forNetwork[networkName].forToken[tokenAddress].forRelayer[\n        railgunAddress\n      ] ??= { forIdentifier: {} };\n\n      this.cache.forNetwork[networkName].forToken[tokenAddress].forRelayer[\n        railgunAddress\n      ].forIdentifier[identifier ?? DEFAULT_RELAYER_IDENTIFIER] =\n        tokenFeeMap[tokenAddress];\n    });\n  }\n\n  static resetCache(chain: Chain) {\n    const network = networkForChain(chain);\n    if (!network) {\n      return;\n    }\n    this.cache.forNetwork ??= {};\n    delete this.cache.forNetwork[network.name];\n  }\n\n  static feesForChain(chain: Chain): Optional<RelayerFeeNetworkCacheMap> {\n    const network = networkForChain(chain);\n    if (!network) {\n      throw new Error('Chain not found.');\n    }\n    return this.cache.forNetwork[network.name];\n  }\n\n  static feesForToken(\n    chain: Chain,\n    tokenAddress: string,\n  ): Optional<RelayerFeeNetworkTokenCacheMap> {\n    return this.feesForChain(chain)?.forToken[tokenAddress.toLowerCase()];\n  }\n\n  static supportsToken(\n    chain: Chain,\n    tokenAddress: string,\n    useRelayAdapt: boolean,\n  ): boolean {\n    const feesForToken = this.feesForToken(chain, tokenAddress);\n    if (!feesForToken) {\n      return false;\n    }\n\n    const railgunAddresses = Object.keys(feesForToken.forRelayer);\n    const filteredRailgunAddresses = AddressFilter.filter(railgunAddresses);\n\n    const cachedFees: CachedTokenFee[] = filteredRailgunAddresses\n      .map(railgunAddress =>\n        Object.values(feesForToken.forRelayer[railgunAddress].forIdentifier),\n      )\n      .flat();\n\n    const availableUnexpiredFee = cachedFees.find(\n      cachedFee =>\n        !cachedFeeUnavailableOrExpired(cachedFee, chain, useRelayAdapt),\n    );\n    return availableUnexpiredFee != null;\n  }\n}\n"]}