{"version":3,"file":"waku-relayer-waku-core.js","sourceRoot":"","sources":["../../src/waku/waku-relayer-waku-core.ts"],"names":[],"mappings":"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","sourcesContent":["import { Chain, promiseTimeout } from '@railgun-community/shared-models';\nimport { waitForRemotePeer, createEncoder } from '@waku/core';\nimport { Protocols, IMessage, RelayNode } from '@waku/interfaces';\nimport { WakuObservers } from './waku-observers';\nimport { RelayerDebug } from '../utils/relayer-debug';\nimport { RelayerFeeCache } from '../fees/relayer-fee-cache';\nimport { utf8ToBytes } from '../utils/conversion';\nimport { isDefined } from '../utils/is-defined';\nimport { bootstrap } from '@libp2p/bootstrap';\nimport { createRelayNode } from '@waku/create';\nimport { RelayerOptions } from '../models';\nimport {\n  WAKU_RAILGUN_DEFAULT_PEERS,\n  WAKU_RAILGUN_PUB_SUB_TOPIC,\n} from '../models/constants';\n\nexport class WakuRelayerWakuCore {\n  static hasError = false;\n\n  static waku: Optional<RelayNode>;\n\n  private static pubSubTopic = WAKU_RAILGUN_PUB_SUB_TOPIC;\n  private static additionalDirectPeers: string[] = [];\n  private static peerDiscoveryTimeout = 60000;\n\n  static initWaku = async (chain: Chain): Promise<void> => {\n    try {\n      await WakuRelayerWakuCore.connect();\n      if (!WakuRelayerWakuCore.waku) {\n        RelayerDebug.log('No waku instance found');\n        return;\n      }\n      WakuObservers.resetCurrentChain();\n      await WakuObservers.setObserversForChain(WakuRelayerWakuCore.waku, chain);\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      RelayerDebug.error(err);\n      throw err;\n    }\n  };\n\n  static reinitWaku = async (chain: Chain) => {\n    if (\n      isDefined(WakuRelayerWakuCore.waku) &&\n      WakuRelayerWakuCore.waku.isStarted()\n    ) {\n      await WakuRelayerWakuCore.disconnect();\n    }\n\n    // Resets connection status to \"Connecting\" for this network.\n    RelayerFeeCache.resetCache(chain);\n\n    await WakuRelayerWakuCore.initWaku(chain);\n  };\n\n  static setRelayerOptions(relayerOptions: RelayerOptions) {\n    if (isDefined(relayerOptions.pubSubTopic)) {\n      WakuRelayerWakuCore.pubSubTopic = relayerOptions.pubSubTopic;\n    }\n    if (relayerOptions.additionalDirectPeers) {\n      WakuRelayerWakuCore.additionalDirectPeers =\n        relayerOptions.additionalDirectPeers;\n    }\n    if (isDefined(relayerOptions.peerDiscoveryTimeout)) {\n      WakuRelayerWakuCore.peerDiscoveryTimeout =\n        relayerOptions.peerDiscoveryTimeout;\n    }\n  }\n\n  static disconnect = async () => {\n    await WakuRelayerWakuCore.waku?.stop();\n    WakuRelayerWakuCore.waku = undefined;\n  };\n\n  private static connect = async (): Promise<void> => {\n    try {\n      WakuRelayerWakuCore.hasError = false;\n\n      RelayerDebug.log(`Creating waku relay client`);\n\n      const peers: string[] = [\n        ...WAKU_RAILGUN_DEFAULT_PEERS,\n        ...this.additionalDirectPeers,\n      ];\n      const waitTimeoutBeforeBootstrap = 250; // 250 ms - default is 1000ms\n      const waku: RelayNode = await createRelayNode({\n        pubSubTopic: WakuRelayerWakuCore.pubSubTopic,\n        libp2p: {\n          peerDiscovery: [\n            bootstrap({\n              list: peers,\n              timeout: waitTimeoutBeforeBootstrap,\n            }),\n          ],\n        },\n      });\n\n      RelayerDebug.log('Start Waku.');\n      await waku.start();\n\n      RelayerDebug.log('Waiting for remote peer.');\n      await this.waitForRemotePeer(waku);\n\n      if (!isDefined(waku.relay)) {\n        throw new Error('No Waku Relay instantiated.');\n      }\n\n      RelayerDebug.log('Waku peers:');\n      for (const peer of waku.relay.getMeshPeers()) {\n        RelayerDebug.log(JSON.stringify(peer));\n      }\n\n      RelayerDebug.log('Connected to Waku');\n      WakuRelayerWakuCore.waku = waku;\n      WakuRelayerWakuCore.hasError = false;\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      WakuRelayerWakuCore.hasError = true;\n      throw err;\n    }\n  };\n\n  static getMeshPeerCount(): number {\n    return this.waku?.relay.getMeshPeers().length ?? 0;\n  }\n\n  private static async waitForRemotePeer(waku: RelayNode) {\n    try {\n      const protocols = [Protocols.Relay];\n      await promiseTimeout(\n        waitForRemotePeer(waku, protocols),\n        WakuRelayerWakuCore.peerDiscoveryTimeout,\n      );\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      RelayerDebug.error(err);\n      throw new Error(err.message);\n    }\n  }\n\n  static async relayMessage(data: object, contentTopic: string): Promise<void> {\n    if (!WakuRelayerWakuCore.waku?.relay) {\n      throw new Error('No Waku Relay found.');\n    }\n\n    const dataString = JSON.stringify(data);\n    const payload = utf8ToBytes(dataString);\n    const message: IMessage = { payload };\n\n    try {\n      await WakuRelayerWakuCore.waku.relay.send(\n        createEncoder({ contentTopic }),\n        message,\n      );\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      RelayerDebug.error(err);\n    }\n  }\n}\n"]}