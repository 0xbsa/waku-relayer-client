{"version":3,"file":"relayer-transaction.js","sourceRoot":"","sources":["../../src/transact/relayer-transaction.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  getRailgunWalletAddressData,\n  encryptDataWithSharedKey,\n  getCompletedTxidFromNullifiers,\n} from '@railgun-community/wallet';\nimport {\n  Chain,\n  EncryptDataWithSharedKeyResponse,\n  poll,\n  RelayerEncryptedMethodParams,\n  RelayerRawParamsTransact,\n} from '@railgun-community/shared-models';\nimport { RelayerConfig } from '../models/relayer-config';\nimport { bytesToHex } from '../utils/conversion';\nimport { RelayerDebug } from '../utils/relayer-debug';\nimport { isDefined } from '../utils/is-defined';\nimport { WakuRelayerWakuCore } from '../waku/waku-relayer-waku-core';\nimport { contentTopics } from '../waku/waku-topics';\nimport {\n  WakuTransactResponse,\n  RelayerTransactResponse,\n} from './relayer-transact-response';\nimport { getAddress, isHexString } from 'ethers';\n\n//\n// Transact: Encryption Flow\n//\n// Client:\n// 1. Generates random 16 bytes: `responseKey` and adds to transact data\n// 2. Generates a `sharedKey` from a random `privkey` and the Relayer's `pubkey`\n// 3. Encrypts the transact data asymmetrically, using `sharedKey` (`encryptedData = encrypt(transactData, sharedKey)`)\n// 4. Includes `publicKey` and `encryptedData` in transact message\n// 5. Sends the message\n//\n// Relayer:\n// 1. Decrypts the `encryptedData` using Relayer privkey and `sharedKey` (if error, it's not addressed to us)\n// 2. Processes transaction\n// 3. Encrypts response (`txHash` or `error`) using `responseKey` (symmetric: AES-GCM-256)\n// 4. Sends back encrypted response on transact-response: {encryptedData}\n//\n// Client:\n// 1. Catches all `transact-response`'s after sending a transaction.\n// 2. Decrypts each using the `responseKey`. (If error, not addressed to us)\n// 3. After successful decryption, parses `txHash` or `error`.\n//\n\nenum RelayRetryState {\n  RetryTransact = 'RetryTransact',\n  Wait = 'Wait',\n  Timeout = 'Timeout',\n}\n\ntype RelayMessageData = {\n  method: string;\n  params: RelayerEncryptedMethodParams;\n};\n\n// NOTE: Relayer default transaction-send timeout is 45 seconds.\nconst SECONDS_PER_RETRY = 1.5;\nconst POLL_DELAY_SECONDS = 0.1;\nconst RETRY_TRANSACTION_SECONDS = 15;\nconst POST_ALERT_TOTAL_WAITING_SECONDS = 60;\n\nexport class RelayerTransaction {\n  private messageData: RelayMessageData;\n  private contentTopic: string;\n  private chain: Chain;\n  private nullifiers: string[];\n\n  private constructor(\n    encryptedDataResponse: EncryptDataWithSharedKeyResponse,\n    chain: Chain,\n    nullifiers: string[],\n  ) {\n    this.messageData = {\n      method: 'transact',\n      params: {\n        pubkey: encryptedDataResponse.randomPubKey,\n        encryptedData: encryptedDataResponse.encryptedData,\n      },\n    };\n    this.contentTopic = contentTopics.transact(chain);\n    this.chain = chain;\n    this.nullifiers = nullifiers;\n    RelayerTransactResponse.setSharedKey(encryptedDataResponse.sharedKey);\n  }\n\n  static async create(\n    to: string,\n    data: string,\n    relayerRailgunAddress: string,\n    relayerFeesID: string,\n    chain: Chain,\n    nullifiers: string[],\n    overallBatchMinGasPrice: bigint,\n    useRelayAdapt: boolean,\n  ): Promise<RelayerTransaction> {\n    const encryptedDataResponse = await this.encryptTransaction(\n      to,\n      data,\n      relayerRailgunAddress,\n      relayerFeesID,\n      chain,\n      overallBatchMinGasPrice,\n      useRelayAdapt,\n    );\n    return new RelayerTransaction(encryptedDataResponse, chain, nullifiers);\n  }\n\n  private static async encryptTransaction(\n    to: string,\n    data: string,\n    relayerRailgunAddress: string,\n    relayerFeesID: string,\n    chain: Chain,\n    overallBatchMinGasPrice: bigint,\n    useRelayAdapt: boolean,\n  ): Promise<EncryptDataWithSharedKeyResponse> {\n    if (!isHexString(data)) {\n      throw new Error('Data field must be a hex string.');\n    }\n\n    const { viewingPublicKey: relayerViewingKey } = getRailgunWalletAddressData(\n      relayerRailgunAddress,\n    );\n\n    const transactData: RelayerRawParamsTransact = {\n      to: getAddress(to),\n      data,\n      relayerViewingKey: bytesToHex(relayerViewingKey),\n      chainID: chain.id,\n      chainType: chain.type,\n      minGasPrice: overallBatchMinGasPrice.toString(),\n      feesID: relayerFeesID,\n      useRelayAdapt,\n      devLog: RelayerConfig.IS_DEV,\n      minVersion: RelayerConfig.MINIMUM_RELAYER_VERSION,\n      maxVersion: RelayerConfig.MAXIMUM_RELAYER_VERSION,\n    };\n\n    const encryptedDataResponse = await encryptDataWithSharedKey(\n      transactData,\n      relayerViewingKey,\n    );\n\n    return encryptedDataResponse;\n  }\n\n  private async findMatchingNullifierTxid(): Promise<Optional<string>> {\n    try {\n      const { txid } = await getCompletedTxidFromNullifiers(\n        this.chain,\n        this.nullifiers,\n      );\n      return txid;\n    } catch (err) {\n      if (!(err instanceof Error)) {\n        throw err;\n      }\n      RelayerDebug.error(err);\n      return undefined;\n    }\n  }\n\n  private async getTransactionResponse(): Promise<\n    Optional<WakuTransactResponse>\n  > {\n    if (RelayerTransactResponse.storedTransactionResponse) {\n      return RelayerTransactResponse.storedTransactionResponse;\n    }\n\n    const nullifiersTxid = await this.findMatchingNullifierTxid();\n    if (isDefined(nullifiersTxid)) {\n      return {\n        id: 'nullifier-transaction',\n        txHash: nullifiersTxid,\n      };\n    }\n\n    return undefined;\n  }\n\n  private getRelayRetryState(retryNumber: number): RelayRetryState {\n    const retrySeconds = retryNumber * SECONDS_PER_RETRY;\n    if (retrySeconds <= RETRY_TRANSACTION_SECONDS) {\n      return RelayRetryState.RetryTransact;\n    }\n    if (retrySeconds >= POST_ALERT_TOTAL_WAITING_SECONDS) {\n      return RelayRetryState.Timeout;\n    }\n    return RelayRetryState.Wait;\n  }\n\n  async send(): Promise<string> {\n    return this.relay();\n  }\n\n  private async relay(retryNumber = 0): Promise<string> {\n    const relayRetryState = this.getRelayRetryState(retryNumber);\n    switch (relayRetryState) {\n      case RelayRetryState.RetryTransact:\n        // 0-20 seconds.\n        RelayerDebug.log(\n          `Relay Waku message: ${this.messageData.method} via ${this.contentTopic}`,\n        );\n        await WakuRelayerWakuCore.relayMessage(\n          this.messageData,\n          this.contentTopic,\n        );\n        break;\n      case RelayRetryState.Wait:\n        // 21-60 seconds.\n        // Do nothing.\n        break;\n      case RelayRetryState.Timeout:\n        // Exactly 60 seconds.\n        throw new Error('Request timed out.');\n    }\n\n    // 15 iterations (1.5 sec total, iterate every 100ms).\n    const pollIterations = SECONDS_PER_RETRY / POLL_DELAY_SECONDS;\n\n    const response: Optional<WakuTransactResponse> = await poll(\n      async () => this.getTransactionResponse(),\n      (result: Optional<WakuTransactResponse>) => result != null,\n      POLL_DELAY_SECONDS * 1000,\n      pollIterations,\n    );\n    if (isDefined(response)) {\n      if (isDefined(response.txHash)) {\n        RelayerTransactResponse.clearSharedKey();\n        return response.txHash;\n      }\n      if (isDefined(response.error)) {\n        RelayerTransactResponse.clearSharedKey();\n        throw new Error(response.error);\n      }\n    }\n\n    // Retry.\n    return this.relay(retryNumber + 1);\n  }\n}\n"]}